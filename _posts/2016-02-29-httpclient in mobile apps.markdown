---
layout: post
title: "httpclient in mobile apps"
date: 2016-02-29 15:23:00 +0100
comments: true
published: true
categories: ["post"]
tags: [".Net", "Xamarin"]
alias: ["/blog/post/2016/02/29/HttpClient-in-mobile-apps.aspx", "/blog/post/2016/02/29/httpclient-in-mobile-apps.aspx"]
author: Nico Vermeir
redirect_from:
 - /blog/post/2016/02/29/HttpClient-in-mobile-apps.aspx
 - /blog/post/2016/02/29/httpclient-in-mobile-apps.aspx
---
<p>I’ve been seeing a lot of discussions lately on how to correctly use HttpClient in mobile apps, both UWP and / or Xamarin apps. In this post I’d like to share how I currently use HttpClient in my apps.</p>  <p>Read this first -&gt; Disclaimer</p>  <p>This article discusses how I use the HttpClient class. If you use it in a different way or don’t agree with what I write here, feel free to start a constructive discussion in the comments. I’ll be happy to discuss your way of thinking vs mine and adjust the article where necessary.</p>  <p>To single-instance or to multi-instance</p>  <p>Back when I was getting into writing mobile apps (in the WP7 era) I started learning about REST services and how to call them from .NET code. I learned about HttpClient and quickly found out that it implemented IDisposable, so the logical step was the using keyword.</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/ceb1f54a4f8ff0377b79.js"></script>  <p>Turns out, not the best way to go at it. When you dispose an HttpClient instance, the connection to the server is closed.    <br />When you do the next call to the server, with a new HttpClient instance, that connection is reopened. This causes delay in getting a response from the webservice. If a server really doesn’t want you to keep your connection open, it will inform us of that via a header and the HttpClient instance will quietly close the connection and reopen it the next time.</p>  <p>So, how do we create an easy to (re)use instance?</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/7084272960ca5eb8520a.js"></script>  <p>And to use this instance:</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/cc409670c94599a1708d.js"></script>  <h2>Use a base URL (and don’t even dare making it a magic string)</h2>  <p>The HttpClient class has a base url property. As you might have figured out, that property is meant to contain the root url of your API. So if we modify our HttpClient a bit we get this</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/8a01597d074fed66a107.js"></script>  <p>As for the magic strings remark, put all your&#160; string values into a constants class (or whatever you want to name it, as long as they’re all together). If you don’t understand the reasoning behind this, just try writing applications with string values in the code, you’ll find out soon enough <img class="wlEmoticon wlEmoticon-smile" style="border-top-style: none; border-left-style: none; border-bottom-style: none; border-right-style: none" alt="Smile" src="http://www.spikie.be/blog/images/wlEmoticon-smile_33.png" /></p>  <h2>Use compression where possible</h2>  <p>Since we’re mostly writing mobile applications we need to keep data usage in mind. We have no idea if our users will have an expensive data plan or unlimited data or if they’re on WIFI. This means that it’s our job as developers to keep the data usage as low as possible. The quickest win here is to compress the data from the server and decompress it on the device, this of course means that the server needs to support compression. If you yourself maintain the server, make sure that it is enabled (it’s enabled by default in Web API). Once that is enabled, we need to tell the HttpClient to enable decompression from either Deflate or Gzip formats. Enable decompression is done through an HttpClientHandler object that we can pass into the HttpClient constructor.</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/a9bfd00d1fc70423f5cf.js"></script>  <h2>Caching</h2>  <p>Another often overlooked way of limiting data usage is caching. You’d be surprised of the times users request the same data, if we cache the API result we can just fetch it from that cache again. Extra usability feature here is that we can actually show results when the device is offline. You can write your own caching framework if you want, or use one of the existing ones. I tend to switch between <a href="https://github.com/Q42/Q42.WinRT" target="_blank">Q42</a> (they save cached data in JSON files) and <a href="https://github.com/akavache/Akavache" target="_blank">Akavache</a> (they save cached data in SQLite).</p>  <h2>Security Tokens</h2>  <p>We often need to make API calls to secured services. To do this we need to go through some form of authorization / authentication flow where we get an access token from (a bearer token for example). That token needs to be passed in with every API call we make. Since we’re now using a single instance for our HttpClient, it would be nice to specify the token once and be done with it. This an easily be done by using the default headers. HttpClient contains a collection of headers that it will use with every call it makes. This is how you add a Bearer token for example:</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/2eead7b195262eab1e3a.js"></script>  <h2>Use ConfigureAwait(false)</h2>  <p>HttpClient is an async library. This means that we usually use this in a method that returns either Task or Task&lt;T&gt;. This also means that if you don’t use ConfigureAwait(false) that you’ll create quite a lot of context switching. When you await an async method, and don’t specify ConfigureAwait(false), the method will do it’s thing on the thread pool and switch back to the caller’s context when finished. This is exactly the behavior that you want when you request a webresult and immediately put the data into a property that is bound against, since binding happens on the UI thread. But this is not what we want when we’re executing code in a library or in a service class, so that’s where we’ll use ConfigureAwait(false).</p>  <p>Let’s say, for example, that we have a method to fetch all resources as a JSON string. The correct way of using ConfigureAwait(false) would be:</p> <script type="text/javascript" src="https://gist.github.com/NicoVermeir/5e899755969f678b5b5e.js"></script>  <p>The FetchData method doesn’t use ConfigureAwait(false) because it needs to return to the caller context. The caller context here is the UI thread. The property that the returned value is being set to will trigger a change notification, so we need to be on the UI thread.</p>  <p>The FetchAllResources method has two calls that are awaited, by not returning to caller context in that method we prevent two context switches to occur.</p>  <h2>(Xamarin only) use ModernHttpClient</h2>  <p>Xamarin allows us to write iOS and Android applications in C#. We can use the HttpClient for that but we'd be using an abstraction of the lowest common denominator of both platforms. If you use <a href="https://github.com/paulcbetts/ModernHttpClient" target="_blank">ModernHttpClient </a>on those platforms instead, you will get the full networking stack of the respective platforms. (thanks for reminding me @Depechie)</p>  <h2>Conclusion</h2>  <p>In this post I discussed some techniques with using HttpClient to fetch data in mobile applications that I’ve picked up over the years. As I’ve mentioned in the disclaimer, this is what I’m doing today and what feels right to me. Feel free to let me know if you do things another way, if you can convince me that your way is better, I will have learned something and will update the post accordingly <img class="wlEmoticon wlEmoticon-smile" style="border-top-style: none; border-left-style: none; border-bottom-style: none; border-right-style: none" alt="Smile" src="http://www.spikie.be/blog/images/wlEmoticon-smile_33.png" />.</p>
{% include imported_disclaimer.html %}
